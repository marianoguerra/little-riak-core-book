<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>How a Command Works &mdash; Little Riak Core Book 1.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Little Riak Core Book 1.0 documentation" href="index.html" />
    <link rel="next" title="Adding our First Commands" href="adding-our-first-commands.html" />
    <link rel="prev" title="Users, Groups and Permissions" href="users-groups-and-permissions.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="how-a-command-works">
<h1>How a Command Works<a class="headerlink" href="#how-a-command-works" title="Permalink to this headline">Â¶</a></h1>
<p>Enough with the setup, let&#8217;s see how ping works under the covers.</p>
<p>Its entry point and public API is the tanodb module, that means we have to
look into tanodb.erl:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">tanodb</span><span class="p">).</span>
<span class="p">-</span><span class="ni">include_lib</span><span class="p">(</span><span class="s">&quot;riak_core/include/riak_core_vnode.hrl&quot;</span><span class="p">).</span>

<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">ping</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="p">-</span><span class="ni">ignore_xref</span><span class="p">([</span><span class="n">ping</span><span class="o">/</span><span class="mi">0</span><span class="p">]).</span>

<span class="c">%% Public API</span>

<span class="c">%% @doc Pings a random vnode to make sure communication is functional</span>
<span class="nf">ping</span><span class="p">()</span> <span class="o">-&gt;</span>
    <span class="nn">tanodb_metrics</span><span class="p">:</span><span class="nf">core_ping</span><span class="p">(),</span>
    <span class="nv">DocIdx</span> <span class="o">=</span> <span class="nn">riak_core_util</span><span class="p">:</span><span class="nf">chash_key</span><span class="p">({</span><span class="o">&lt;&lt;</span><span class="s">&quot;ping&quot;</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">term_to_binary</span><span class="p">(</span><span class="nn">os</span><span class="p">:</span><span class="nf">timestamp</span><span class="p">())}),</span>
    <span class="nv">PrefList</span> <span class="o">=</span> <span class="nn">riak_core_apl</span><span class="p">:</span><span class="nf">get_primary_apl</span><span class="p">(</span><span class="nv">DocIdx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tanodb</span><span class="p">),</span>
    <span class="p">[{</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="p">_</span><span class="nv">Type</span><span class="p">}]</span> <span class="o">=</span> <span class="nv">PrefList</span><span class="p">,</span>
    <span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">sync_spawn_command</span><span class="p">(</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="n">ping</span><span class="p">,</span> <span class="n">tanodb_vnode_master</span><span class="p">).</span>
</pre></div>
</div>
<p>We see we have our ping function there as the only public API and it does some
funny stuff.</p>
<p>I won&#8217;t go into much riak_core details that are described elsewhere since here
we cover the practical aspects, there are many useful talks about riak_core
internals and theory around, you can watch them:</p>
<ul class="simple">
<li><a class="reference external" href="https://vimeo.com/18758206">Rusty Klophaus - Masterless Distributed Computing with Riak Core</a></li>
<li><a class="reference external" href="https://vimeo.com/21772889">Andy Gross - Riak Core - An Erlang Distributed Systems Toolkit</a></li>
</ul>
<p>There are also some detailed articles about it:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/rzezeski/try-try-try">Ryan Zezeski&#8217;s &#8220;working&#8221; blog</a></li>
<li><a class="reference external" href="https://github.com/basho/riak_core/wiki">Riak Core Wiki</a></li>
<li><a class="reference external" href="http://basho.com/posts/technical/where-to-start-with-riak-core/">Where To Start With Riak Core</a></li>
</ul>
<p>But let&#8217;s look at what it does line by line:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nn">tanodb_metrics</span><span class="p">:</span><span class="nf">core_ping</span><span class="p">(),</span>
</pre></div>
</div>
<p>First we register the operation in our metrics, we covered this in previous chapters.</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">DocIdx</span> <span class="o">=</span> <span class="nn">riak_core_util</span><span class="p">:</span><span class="nf">chash_key</span><span class="p">({</span><span class="o">&lt;&lt;</span><span class="s">&quot;ping&quot;</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">term_to_binary</span><span class="p">(</span><span class="nn">os</span><span class="p">:</span><span class="nf">timestamp</span><span class="p">())}),</span>
</pre></div>
</div>
<p>The line above hashes a key to decide to which vnode the call should go, a
riak_core app has a fixed number of vnodes that are distributed across all the
instances of your app&#8217;s physical nodes, vnodes move from instance to instance
when the number of instances change to balance the load and provide fault
tolerance and scalability.</p>
<p>The call above will allow us to ask for vnodes that can handle that hashed key,
let&#8217;s run it in the app console to see what it does:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">1</span><span class="o">&gt;</span> <span class="nv">DocIdx</span> <span class="o">=</span> <span class="nn">riak_core_util</span><span class="p">:</span><span class="nf">chash_key</span><span class="p">({</span><span class="o">&lt;&lt;</span><span class="s">&quot;ping&quot;</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="nb">term_to_binary</span><span class="p">(</span><span class="nn">os</span><span class="p">:</span><span class="nf">timestamp</span><span class="p">())}).</span>

<span class="o">&lt;&lt;</span><span class="mi">126</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">218</span><span class="p">,</span><span class="mi">77</span><span class="p">,</span><span class="mi">97</span><span class="p">,</span><span class="mi">108</span><span class="p">,</span><span class="mi">38</span><span class="p">,</span><span class="mi">92</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">155</span><span class="p">,</span><span class="mi">160</span><span class="p">,</span><span class="mi">26</span><span class="p">,</span><span class="mi">161</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">134</span><span class="p">,</span><span class="mi">213</span><span class="p">,</span><span class="mi">167</span><span class="p">,</span><span class="mi">168</span><span class="o">&gt;&gt;</span>
</pre></div>
</div>
<p>We seem to get a binary back, in the next line we ask for a list of vnodes that
can handle that hashed key:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nv">PrefList</span> <span class="o">=</span> <span class="nn">riak_core_apl</span><span class="p">:</span><span class="nf">get_primary_apl</span><span class="p">(</span><span class="nv">DocIdx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tanodb</span><span class="p">),</span>
</pre></div>
</div>
<p>let&#8217;s run it to see what it does:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">2</span><span class="o">&gt;</span> <span class="nv">PrefList</span> <span class="o">=</span> <span class="nn">riak_core_apl</span><span class="p">:</span><span class="nf">get_primary_apl</span><span class="p">(</span><span class="nv">DocIdx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tanodb</span><span class="p">).</span>

<span class="p">[{{</span><span class="mi">730750818665451459101842416358141509827966271488</span><span class="p">,</span> <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span>
     <span class="n">primary</span><span class="p">}]</span>
</pre></div>
</div>
<p>We get a list with one tuple that has 3 items, a long number, something that looks like a host
and an atom, let&#8217;s try changing the number 1:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">3</span><span class="o">&gt;</span> <span class="nv">PrefList2</span> <span class="o">=</span> <span class="nn">riak_core_apl</span><span class="p">:</span><span class="nf">get_primary_apl</span><span class="p">(</span><span class="nv">DocIdx</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">tanodb</span><span class="p">).</span>

<span class="p">[{{</span><span class="mi">730750818665451459101842416358141509827966271488</span><span class="p">,</span>
   <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span> <span class="n">primary</span><span class="p">},</span>
 <span class="p">{{</span><span class="mi">753586781748746817198774991869333432010090217472</span><span class="p">,</span>
   <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span> <span class="n">primary</span><span class="p">}]</span>
</pre></div>
</div>
<p>Now we get two tuples, the first one is the same, so what this does is to return
the number of vnodes that can handle the request from the hashed key by priority.</p>
<p>Btw, the first number is the vnode id, it&#8217;s what we get on the ping response :)</p>
<p>Next line just unpacks the pref list to get the vnode id and ignore the other part:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">[{</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="p">_</span><span class="nv">Type</span><span class="p">}]</span> <span class="o">=</span> <span class="nv">PrefList</span><span class="p">,</span>
</pre></div>
</div>
<p>And finally we ask riak_core to call the ping command on the IndexNode we got back:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">sync_spawn_command</span><span class="p">(</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="n">ping</span><span class="p">,</span> <span class="n">tanodb_vnode_master</span><span class="p">).</span>
</pre></div>
</div>
<p>Let&#8217;s try it on the console:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">5</span><span class="o">&gt;</span> <span class="p">[{</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="p">_</span><span class="nv">Type</span><span class="p">}]</span> <span class="o">=</span> <span class="nv">PrefList</span><span class="p">.</span>

<span class="p">[{{</span><span class="mi">730750818665451459101842416358141509827966271488</span><span class="p">,</span>
   <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span> <span class="n">primary</span><span class="p">}]</span>

<span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">6</span><span class="o">&gt;</span> <span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">sync_spawn_command</span><span class="p">(</span><span class="nv">IndexNode</span><span class="p">,</span> <span class="n">ping</span><span class="p">,</span> <span class="n">tanodb_vnode_master</span><span class="p">).</span>

<span class="p">{</span><span class="n">pong</span><span class="p">,</span><span class="mi">730750818665451459101842416358141509827966271488</span><span class="p">}</span>
</pre></div>
</div>
<p>You can see we get IndexNode back in the pong response, now let&#8217;s try passing the second IndexNode:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">7</span><span class="o">&gt;</span> <span class="p">[{</span><span class="nv">IndexNode1</span><span class="p">,</span> <span class="p">_</span><span class="nv">Type1</span><span class="p">},</span> <span class="p">{</span><span class="nv">IndexNode2</span><span class="p">,</span> <span class="p">_</span><span class="nv">Type2</span><span class="p">}]</span> <span class="o">=</span> <span class="nv">PrefList2</span><span class="p">.</span>

<span class="p">[{{</span><span class="mi">730750818665451459101842416358141509827966271488</span><span class="p">,</span>
   <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span> <span class="n">primary</span><span class="p">},</span>
 <span class="p">{{</span><span class="mi">753586781748746817198774991869333432010090217472</span><span class="p">,</span>
   <span class="n">&#39;tanodb@127.0.0.1&#39;</span><span class="p">},</span> <span class="n">primary</span><span class="p">}]</span>


<span class="p">(</span><span class="n">tanodb</span><span class="p">@</span><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span><span class="mi">9</span><span class="o">&gt;</span> <span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">sync_spawn_command</span><span class="p">(</span><span class="nv">IndexNode2</span><span class="p">,</span> <span class="n">ping</span><span class="p">,</span> <span class="n">tanodb_vnode_master</span><span class="p">).</span>

<span class="p">{</span><span class="n">pong</span><span class="p">,</span><span class="mi">753586781748746817198774991869333432010090217472</span><span class="p">}</span>
</pre></div>
</div>
<p>We get the IndexNode2 back, that means that the request was sent to the second
vnode instead of the first one.</p>
<p>But where does the command go? the road is explained in this scientific chart:</p>
<div class="highlight-python"><div class="highlight"><pre>tano.erl -&gt; riak_core magic -&gt; tano_vnode.erl
</pre></div>
</div>
<p>let&#8217;s see the content of tanodb_vnode.erl (just the useful parts):</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">tanodb_vnode</span><span class="p">).</span>
<span class="p">-</span><span class="ni">behaviour</span><span class="p">(</span><span class="n">riak_core_vnode</span><span class="p">).</span>

<span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start_vnode</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">init</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">terminate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_command</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>
         <span class="n">is_empty</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">delete</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">handle_handoff_command</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>
         <span class="n">handoff_starting</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handoff_cancelled</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">handoff_finished</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_handoff_data</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">encode_handoff_item</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_coverage</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
         <span class="n">handle_exit</span><span class="o">/</span><span class="mi">3</span><span class="p">]).</span>

<span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">state</span><span class="p">,</span> <span class="p">{</span><span class="n">partition</span><span class="p">}).</span>

<span class="c">%% API</span>
<span class="nf">start_vnode</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">get_vnode_pid</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span> <span class="o">?</span><span class="nv">MODULE</span><span class="p">).</span>

<span class="nf">init</span><span class="p">([</span><span class="nv">Partition</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nl">#state</span> <span class="p">{</span> <span class="n">partition</span><span class="o">=</span><span class="nv">Partition</span> <span class="p">}}.</span>

<span class="c">%% Sample command: respond to a ping</span>
<span class="nf">handle_command</span><span class="p">(</span><span class="n">ping</span><span class="p">,</span> <span class="p">_</span><span class="nv">Sender</span><span class="p">,</span> <span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="p">{</span><span class="n">pong</span><span class="p">,</span> <span class="nv">State</span><span class="nl">#state.partition</span><span class="p">},</span> <span class="nv">State</span><span class="p">};</span>
<span class="nf">handle_command</span><span class="p">(</span><span class="nv">Message</span><span class="p">,</span> <span class="p">_</span><span class="nv">Sender</span><span class="p">,</span> <span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">lager</span><span class="p">:</span><span class="nf">warning</span><span class="p">(</span><span class="s">&quot;unhandled_command </span><span class="si">~p</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Message</span><span class="p">]),</span>
    <span class="p">{</span><span class="n">noreply</span><span class="p">,</span> <span class="nv">State</span><span class="p">}.</span>
</pre></div>
</div>
<p>OK, let&#8217;s go by parts, first we declare our module:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">module</span><span class="p">(</span><span class="n">tanodb_vnode</span><span class="p">).</span>
</pre></div>
</div>
<p>Then we specify that we want to implement the riak_core_vnode behavior:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">behaviour</span><span class="p">(</span><span class="n">riak_core_vnode</span><span class="p">).</span>
</pre></div>
</div>
<p>Behaviors in Erlang are like interfaces, a set of functions that a module must
implement to satisfy the behaviour specification, you can read more in the
<a class="reference external" href="http://www.erlang.org/doc/design_principles/des_princ.html">Erlang documentation</a>.</p>
<p>In this case riak_core defines a behavior with a set of functions we must
implement to be a valid riak_core vnode, you can get an idea of the kind of
functionality we need by looking at the exported functions:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">export</span><span class="p">([</span><span class="n">start_vnode</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">init</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">terminate</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_command</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>
         <span class="n">is_empty</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">delete</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">handle_handoff_command</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span>
         <span class="n">handoff_starting</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handoff_cancelled</span><span class="o">/</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">handoff_finished</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_handoff_data</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">encode_handoff_item</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
         <span class="n">handle_coverage</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span>
         <span class="n">handle_exit</span><span class="o">/</span><span class="mi">3</span><span class="p">]).</span>
</pre></div>
</div>
<p>For the moment most of them have a &#8220;dummy&#8221; implementation where they just to
the minimal amount of work to satisfy the behavior and not more, it&#8217;s our job
to change the default implementation to fit our needs.</p>
<p>We will have a record called state to keep info between callbacks, this is
typical Erlang way of managing state so I won&#8217;t cover it here:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">-</span><span class="ni">record</span><span class="p">(</span><span class="nl">state</span><span class="p">,</span> <span class="p">{</span><span class="n">partition</span><span class="p">}).</span>
</pre></div>
</div>
<p>Then we implement the api to start the vnode, nothing fancy:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="c">%% API</span>
<span class="nf">start_vnode</span><span class="p">(</span><span class="nv">I</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">riak_core_vnode_master</span><span class="p">:</span><span class="nf">get_vnode_pid</span><span class="p">(</span><span class="nv">I</span><span class="p">,</span> <span class="o">?</span><span class="nv">MODULE</span><span class="p">).</span>
</pre></div>
</div>
<p>Note that on init we store the Partition value on state so we can use it later,
this is what I referred above as vnode id, it&#8217;s the big number you saw before:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">init</span><span class="p">([</span><span class="nv">Partition</span><span class="p">])</span> <span class="o">-&gt;</span>
    <span class="p">{</span><span class="n">ok</span><span class="p">,</span> <span class="nl">#state</span> <span class="p">{</span> <span class="n">partition</span><span class="o">=</span><span class="nv">Partition</span> <span class="p">}}.</span>
</pre></div>
</div>
<p>And now for the interesting part, here we have our ping command implementation,
we match for ping in the Message position (the first argument):</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">handle_command</span><span class="p">(</span><span class="n">ping</span><span class="p">,</span> <span class="p">_</span><span class="nv">Sender</span><span class="p">,</span> <span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
</pre></div>
</div>
<p>And return a reply response with the second item in the tuple being the actual
response that the caller will get where we reply with the atom pong and the
partition number of this vnode, the last item in the tuple is the new state we
want to have for this vnode, since we didn&#8217;t change anything we pass the
current value:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="p">{</span><span class="n">reply</span><span class="p">,</span> <span class="p">{</span><span class="n">pong</span><span class="p">,</span> <span class="nv">State</span><span class="nl">#state.partition</span><span class="p">},</span> <span class="nv">State</span><span class="p">};</span>
</pre></div>
</div>
<p>And then we implement a catch all that will just log the unknown command and
give no reply back:</p>
<div class="highlight-erlang"><div class="highlight"><pre><span class="nf">handle_command</span><span class="p">(</span><span class="nv">Message</span><span class="p">,</span> <span class="p">_</span><span class="nv">Sender</span><span class="p">,</span> <span class="nv">State</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="nn">lager</span><span class="p">:</span><span class="nf">warning</span><span class="p">(</span><span class="s">&quot;unhandled_command </span><span class="si">~p</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nv">Message</span><span class="p">]),</span>
    <span class="p">{</span><span class="n">noreply</span><span class="p">,</span> <span class="nv">State</span><span class="p">}.</span>
</pre></div>
</div>
<p>So, this is the roundtrip of the ping call, our task to add more commands will
be:</p>
<ul class="simple">
<li>Add a function on tanodb.erl that hides the internal work done to distribute the work</li>
<li>Add a new match on handle_command to match the command we added on tanodb.erl and provide a reply</li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Little Riak Core Book</a></h1>





<p>
<iframe src="https://ghbtns.com/github-btn.html?user=&repo=&type=watch&count=true&size=large"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>


<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="starting.html">Starting</a></li>
<li class="toctree-l1"><a class="reference internal" href="ping-as-a-service.html">Ping as a Service (PaaS)</a></li>
<li class="toctree-l1"><a class="reference internal" href="metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="users-groups-and-permissions.html">Users, Groups and Permissions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">How a Command Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="adding-our-first-commands.html">Adding our First Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="listing-keys-from-a-bucket.html">Listing Keys from a Bucket</a></li>
<li class="toctree-l1"><a class="reference internal" href="tolerating-node-failures.html">Tolerating Node Failures</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="riak_core_metadata.html">Riak Core Metadata</a></li>
<li class="toctree-l1"><a class="reference internal" href="riak_core_security.html">Riak Core Security</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="users-groups-and-permissions.html" title="previous chapter">Users, Groups and Permissions</a></li>
      <li>Next: <a href="adding-our-first-commands.html" title="next chapter">Adding our First Commands</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, Mariano Guerra.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.2.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="_sources/how-a-command-works.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>